
class ActiveRecord::Base #:nodoc:

  # These extensions make models taggable. This file is automatically generated and required by your app if you run the tagging generator included with has_many_polymorphs.
  module TaggingExtensions
    
    # Add tags to <tt>self</tt>. Accepts a string of tagnames, an array of tagnames, an array of ids, or an array of Tags.
    #
    # We need to avoid name conflicts with the built-in ActiveRecord association methods, thus the underscores.
    def _add_tags(list,owner,kind=Tag::GENERIC,weight=1)
      taggable?(true)
      tag_cast_to_string(list).each do |tag_name|
        begin
          tag = Tag.find_or_create_by_name(Tag.normalizename(tag_name))
          raise Tag::Error, "tag could not be saved: #{tag_name}" if tag.new_record?
          Tagging.create(:tag => tag, :taggable => self, :tag_kind => kind, :tag_display => tag_name, :owner => owner, :weight => weight)          
        rescue ActiveRecord::StatementInvalid => e
          raise unless e.to_s =~ /duplicate/i
        rescue Tag::Error => e
          logger.debug("Tag Error #{e.to_s}")
        end
      end
    end
  
    # Removes tags from <tt>self</tt>. Accepts a string of tagnames, an array of tagnames, an array of ids, or an array of Tags.  
    def _remove_tags(list,owner,kind=Tag::GENERIC)
      taggable?(true)
      list = tag_cast_to_string(list,true) # probably redundant
      taggings.reload
      # because of http://dev.rubyonrails.org/ticket/6466
      taggings.delete(*(taggings.find(:all, :include => :tag, :conditions => ["tag_kind = ? AND owner_id =?",kind,owner.id]).select do |tagging| 
        (list.include? tagging.tag.name)  
      end))
      end

   # Returns the tags on <tt>self</tt> as a string.
    def tag_list
      # Redefined later to avoid an RDoc parse error.
    end
  
    # Replace the existing tags on <tt>self</tt>. Accepts a string of tagnames, an array of tagnames, an array of ids, or an array of Tags.
    def tag_with(list,owner,kind,weight=1)    
      #:stopdoc:
      logger.debug "=================================== Inside tag_with: #{self.attributes.inspect}"
      
      taggable?(true)
      list = tag_cast_to_string(list)
           
      # Transactions may not be ideal for you here; be aware.
      Tag.transaction do 
        current_tags = (tags_by_owner_and_kind(owner,kind))
        current = tag_cast_to_string(current_tags)        
        _add_tags(list - current,owner,kind,weight)  # may have dups, but won't create duplicate records
        _remove_tags(current - (list.map{|tag| Tag.normalizename(tag)}),owner,kind)
      end
      
      self
      #:startdoc:
    end

   # Returns the tags on <tt>self</tt> as a string.
    def tag_list #:nodoc:
      #:stopdoc:
      taggable?(true)
      tags.reload
      tags.to_s
      #:startdoc:
    end
    
    def tag_count
      # this may be problematic down the line for an object with a lot of tags
      taggable?(true)
      taggings.reload
      taggings.count(:group => :tag)
    end  
    
    def tag_count_by_owner_and_kind(owner,kind='all')      
      # this may be problematic down the line for an object with a lot of tags
      taggable?(true)
      taggings.reload
      taggings.count(:group => :tag, :conditions => tagcond(owner,kind))
    end
    
    def tags_by_owner_and_kind(owner,kind='all')
      logger.debug "=================================== Inside tags_by_owner_and_kind: #{self.attributes.inspect}"
      
      taggable?(true)
      tags.reload
      # has to be uniq by mysql index
      tags.find(:all, :conditions => tagcond(owner,kind))
    end
    
    def tag_list_by_owner_and_kind(owner,kind='all')
       tags_by_owner_and_kind(owner,kind).map(&:name).join(' ')
    end

     def tag_displaylist_by_owner_and_kind(owner,kind='all',returnarray=false)
       taggable?(true)
       taggings.reload
       array = taggings.find(:all, :conditions => tagcond(owner,kind)).map(&:tag_display)
       if(returnarray)
         array
       else
         array.join(' ')
       end
     end


    def my_top_tags(options={})
     options[:from] ||= "#{self.class.table_name}, tags, taggings"
     sql  = "SELECT tags.*, COUNT(taggings.tag_id) as frequency, SUM(taggings.weight) as weightedfrequency "
     sql << "FROM #{options[:from]} "
     sql << "WHERE #{self.class.table_name}.#{self.class.primary_key} = taggings.taggable_id "
     sql << "AND taggings.taggable_type = '#{self.class.name}' "
     sql << "AND taggings.tag_id = tags.id "
     sql << "AND #{self.class.table_name}.#{self.class.primary_key} = #{self.id} "            
     sql << "AND #{sanitize_sql(options[:conditions])} " if options[:conditions]
     sql << "GROUP BY tags.id "
     if(!options[:minweight].nil?)
       sql << "HAVING SUM(taggings.weight) >= #{options[:minweight]}"
     elsif(!options[:mincount].nil?)
       sql << "HAVING COUNT(taggings.tag_id) >= #{options[:mincount]}"
     end
 
     if(order = options[:order])         
       sql << " ORDER BY #{order}"
     end
 
     if limit = options[:limit]
       if limit.to_s =~ /,/
         limitcondition = limit.to_s.split(',').map{ |i| i.to_i }.join(',')
       else
         limitcondition = limit.to_i
       end
       sql << " LIMIT #{limitcondition}"
     end
     return Tag.find_by_sql(sql)
    end
     
    def my_top_tags_displaylist(options={})
      logger.debug "=================================== Inside my_top_tags_displaylist: #{self.attributes.inspect}"
      my_top_tags(options).map(&:name).join(' ')
    end
    
    
    private
    
    def tag_cast_to_string(obj,normalizestring=false) #:nodoc:
      case obj
        when Array
          obj.map! do |item|
            case item
              when /^\d+$/, Fixnum then Tag.find(item).name # This will be slow if you use ids a lot.
              when Tag then item.name
              when String then normalizestring ? Tag.normalizename(item) : item.strip
              else
                raise "Invalid type"
            end
          end              
        when String
          obj = obj.split(Tag::SPLITTER).map do |tag_name| 
            if(!tag_name.empty?)
              normalizestring ? Tag.normalizename(tag_name) : tag_name.strip
            end
          end
        else
          raise "Invalid object of class #{obj.class} as tagging method parameter"
      end.flatten.compact.uniq
    end 
  
    # Check if a model is in the :taggables target list. The alternative to this check is to explicitly include a TaggingMethods module (which you would create) in each target model.  
    def taggable?(should_raise = false) #:nodoc:
      unless flag = respond_to?(:tags)
        raise "#{self.class} is not a taggable model" if should_raise
      end
      flag
    end
    
    def tagcond(owner,kind)
      if(kind.nil? or kind == 'all')
        "taggings.owner_id = #{owner.id}"
      else
        "taggings.owner_id = #{owner.id} AND taggings.tag_kind = '#{kind}'"
      end
    end

  end
  
  module TaggingFinders
    # 
    # Find all the objects tagged with the supplied list of tags
    # 
    # Usage : Model.tagged_with("ruby")
    #         Model.tagged_with("hello", "world")
    #         Model.tagged_with("hello", "world", :limit => 10)
    #
    
    def tag_cast_to_string(obj,normalizestring=false) #:nodoc:
      case obj
        when Array
          obj.map! do |item|
            case item
              when /^\d+$/, Fixnum then Tag.find(item).name # This will be slow if you use ids a lot.
              when Tag then item.name
              when String then normalizestring ? Tag.normalizename(item) : item.strip
              else
                raise "Invalid type"
            end
          end              
        when String
          obj = obj.split(Tag::SPLITTER).map do |tag_name| 
            if(!tag_name.empty?)
              normalizestring ? Tag.normalizename(tag_name) : tag_name.strip
            end
          end
        else
          raise "Invalid object of class #{obj.class} as tagging method parameter"
      end.flatten.compact.uniq
    end
    
    def tagged_with_any(*tag_list)
      options = tag_list.last.is_a?(Hash) ? tag_list.pop : {}
      tag_list = parse_tags(tag_list)
      
      if(options[:getfrequency])
        options[:select] ||= "#{table_name}.*, tags.id as tag_id, COUNT(taggings.tag_id) as frequency, SUM(taggings.weight) as weightedfrequency"
      else
        options[:select] ||= "#{table_name}.*"
      end
      options[:from] ||= "#{table_name}, tags, taggings"
      
      sql  = "SELECT #{options[:select]} "
      sql << "FROM #{options[:from]} "

      #add_joins!(sql, options, nil)
      
      sql << "WHERE #{table_name}.#{primary_key} = taggings.taggable_id "
      sql << "AND taggings.taggable_type = '#{ActiveRecord::Base.send(:class_name_of_active_record_descendant, self).to_s}' "
      sql << "AND taggings.tag_id = tags.id "
      
      tag_list_condition = tag_list.map {|t| "'#{t}'"}.join(", ")
      sql << "AND (tags.name IN (#{sanitize_sql(tag_list_condition)})) "
      sql << "AND #{sanitize_sql(options[:conditions])} " if options[:conditions]
      if(options[:getfrequency])
        sql << "GROUP BY #{table_name}.id,tag_id "
        if(!options[:minweight].nil?)
          sql << "HAVING SUM(taggings.weight) >= #{options[:minweight]} "
        elsif(!options[:mincount].nil?)
          sql << "HAVING COUNT(taggings.tag_id) >= #{options[:mincount]} "
        end
      else
        sql << "GROUP BY #{table_name}.id "
        matchall = options[:matchall] || false
        if(matchall)
          sql << "HAVING COUNT(taggings.tag_id) = #{tag_list.size} "
        end
      end
      add_order!(sql, options[:order], nil)
      add_limit!(sql, options, nil)
      add_lock!(sql, options, nil)
      
      paginate = options[:paginate] || false
      if(paginate and !options[:getfrequency])  
        paginate_by_sql(sql,{:page => options[:page], :per_page => self.per_page})
      else
        find_by_sql(sql)
      end
    end
    
    
    
    def tag_frequency(options={})
      options[:from] ||= "#{table_name}, tags, taggings"
      
      sql  = "SELECT tags.*, COUNT(taggings.tag_id) as frequency, SUM(taggings.weight) as weightedfrequency "
      sql << "FROM #{options[:from]} "

      #add_joins!(sql, options)
      
      sql << "WHERE #{table_name}.#{primary_key} = taggings.taggable_id "
      sql << "AND taggings.taggable_type = '#{ActiveRecord::Base.send(:class_name_of_active_record_descendant, self).to_s}' "
      sql << "AND taggings.tag_id = tags.id "            
      sql << "AND #{sanitize_sql(options[:conditions])} " if options[:conditions]
      sql << "GROUP BY tags.id "
      if(!options[:minweight].nil?)
        sql << "HAVING SUM(taggings.weight) >= #{options[:minweight]}"
      elsif(!options[:mincount].nil?)
        sql << "HAVING COUNT(taggings.tag_id) >= #{options[:mincount]}"
      end
            
      add_order!(sql, options[:order], nil)
      add_limit!(sql, options, nil)
      add_lock!(sql, options, nil)
      return Tag.find_by_sql(sql)
    end
    
    
    def parse_tags(tags)
      return [] if tags.blank?
      tags = Array(tags).first
      tags = tags.respond_to?(:flatten) ? tags.flatten : tags.split(Tag::SPLITTER)
      tags.map { |tag| Tag.normalizename(tag) }.flatten.compact.uniq
    end
    
  end

  include TaggingExtensions
  extend  TaggingFinders
end
